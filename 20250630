1.scope
# 스코프 & 변수 선언 키워드 총정리

## 1️⃣ 스코프

* **전역 스코프**: 코드 가장 바깥 영역. 전역 변수는 어디서나 참조 가능.
* **지역 스코프**: 함수 몸체 내부 등. 지역 변수는 자신과 하위 스코프에서만 유효.

### ✅ 함수 레벨 vs 블록 레벨

* `var`: 함수 레벨 스코프. 코드 블록(if, for 등) 내부에서도 전역/상위 함수 범위에 묶임.
* `let`, `const`: 블록 레벨 스코프 지원. 코드 블록마다 독립된 스코프 생성.

## 2️⃣ var

* 같은 스코프 내 중복 선언 허용 (문제 유발 가능)
* 함수 레벨 스코프만 지원 → 블록 내 선언해도 전역 변수 취급
* **변수 호이스팅 발생**: 선언이 스코프 최상단으로 끌어올려진 듯 동작 (초기값 undefined)

## 3️⃣ let

* 같은 스코프 내 중복 선언 **금지**
* 블록 레벨 스코프 지원 → 코드 블록마다 별도 변수 영역 유지
* 변수 호이스팅이 발생하지만 **초기화 전 참조 불가** → ReferenceError

## 4️⃣ const

* let과 동일하게 블록 레벨 스코프 + 변수 호이스팅 발생하지만 초기화 전 참조 불가
* 선언 시 반드시 초기화 필요
* **재할당 금지** → 상수처럼 사용

## 5️⃣ 결론 (실전 가이드)

* ES6 환경이라면 **var 쓰지 말자**
* 값 변경 필요 시 `let` → 스코프 최대한 좁게 설계
* 읽기 전용 값 → 무조건 `const` → 안정적 코드 유지

2.object
# 객체 생성자 함수 총정리

## 1️⃣ Object 생성자 함수

* `new Object()` 사용 → 빈 객체 생성 후 프로퍼티 추가 가능
* Object 생성자 함수 말고 **객체 리터럴 사용**이 더 간편함
* JS 내장 생성자 함수: String, Number, Boolean, Function, Array, Date, RegExp 등

## 2️⃣ 사용자 정의 생성자 함수

* 여러 개의 동일한 구조 객체 필요 → 생성자 함수 사용
* 함수 내부에서 `this` 키워드로 프로퍼티, 메서드 정의
* `new` 키워드 사용해 인스턴스 생성

3.프로토타입
# 프로토타입 총정리

## 1️⃣ 상속과 프로토타입 체인

* 객체는 \[\[Prototype]] 숨김 프로퍼티 가짐 → 다른 객체를 참조 가능 → **프로토타입 상속**
* 프로퍼티/메소드 없으면 프로토타입 체인 타고 탐색
* `__proto__` → Object.getPrototypeOf / setPrototypeOf 권장
* 프로토타입 체인 순환 참조 불가

## 2️⃣ 메소드, this

* 프로토타입에서 메소드 공유 → this는 호출한 객체 기준
* 상태(데이터)는 객체별 개별 보유

## 3️⃣ 생성자 함수와 prototype

* 함수 → 기본적으로 prototype 프로퍼티 가짐 → constructor 프로퍼티 포함
* new 생성 시 prototype 객체를 \[\[Prototype]]에 설정

4.배열
# 배열 총정리

## 1️⃣ 배열 생성과 특징

* 여러 값을 순차적으로 나열 → 배열 요소
* 객체 타입이며 인덱스로 요소 접근
* 배열 리터럴, Array 생성자, Array.of 등으로 생성 가능

## 2️⃣ length 프로퍼티

* 배열 요소 개수 나타냄 → 자동 갱신
* 값 조작 가능 → 배열 길이 늘이거나 줄임

## 3️⃣ 배열 메서드

* indexOf, includes → 요소 탐색
* push/pop → 뒤에서 추가/제거
* unshift/shift → 앞에서 추가/제거
* concat → 배열 결합
* slice/splice → 일부 요소 추출/삭제/추가
* join → 문자열로 변환
* reverse → 배열 순서 뒤집기

## 4️⃣ 배열 고차 함수

* forEach → 반복 처리
* map → 변환된 새 배열 반환
* filter → 조건 만족 요소만 새 배열 반환
* some/every → 조건 만족 여부 boolean 반환
* find/findIndex → 조건 만족 첫 요소/인덱스 반환
* sort → 정렬
